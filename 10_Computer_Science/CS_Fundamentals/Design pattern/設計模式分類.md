# 🎨 設計模式三大分類（Design Pattern Categories）

設計模式根據用途可分為三大類：

---

## 🧱 一、Creational Pattern（建立型模式）

> **目的：** 處理物件「建立邏輯」的彈性與簡化

| 模式                          | 說明            | 常見用途          |
| --------------------------- | ------------- | ------------- |
| [`Singleton`](singleton.md) | 保證某類別只有一個實例   | Logger、設定管理   |
| `Factory Method`            | 將建立物件的職責交給子類別 | 多型實現、自訂建立邏輯   |
| `Abstract Factory`          | 建立一系列相關物件的工廠  | 跨平台 UI、樣式組合   |
| `Builder`                   | 將複雜物件的建立流程拆解  | 建造器模式：報表、餐點組合 |
| `Prototype`                 | 複製現有物件產生新實例   | 快速產生相似物件、深複製  |

---

## 🧩 二、Structural Pattern（結構型模式）

> **目的：** 處理類別之間「結構與組合」的方式，提高可維護性

|模式|說明|常見用途|
|---|---|---|
|`Adapter`|將一個類轉換為另一個介面|轉接舊系統、新 API|
|`Facade`|為子系統提供統一簡化介面|封裝複雜子系統|
|`Composite`|樹狀結構的統一操作|檔案系統、UI 元件|
|`Decorator`|動態加入功能而不繼承|權限控制、訊息加密|
|`Proxy`|代理真實物件處理請求|緩存、權限驗證、Lazy load|
|`Bridge`|分離抽象與實作|裝置控制（畫圖工具 + 輸出媒介）|
|`Flyweight`|共享共用物件以節省記憶體|大量相似物件，如字元渲染|

---

## 🎭 三、Behavioral Pattern（行為型模式）

> **目的：** 處理物件間「行為互動」與「責任分配」

|模式|說明|常見用途|
|---|---|---|
|`Observer`|一改全改，訂閱/通知機制|事件處理、GUI|
|`Strategy`|可替換的演算法封裝|折扣策略、排序邏輯|
|`Command`|將請求封裝為命令物件|Undo/Redo、工作排程|
|`State`|根據狀態改變行為|狀態機、連線狀態|
|`Template Method`|定義流程骨架，部分交由子類別實作|演算法步驟固定但可擴充|
|`Mediator`|中介者負責協調多物件|UI 控件協調|
|`Chain of Responsibility`|傳遞請求直到有對象處理|責任鏈審核流程、日誌處理|
|`Visitor`|將新操作加在現有物件上|文件匯出、多格式處理|
|`Interpreter`|自訂語法解譯器|SQL、正則表達式處理器|
|`Memento`|儲存與還原狀態|儲存進度、Undo/Redo|

---

## 🧠 對照整理表

|分類|關注點|解決問題|常見應用|
|---|---|---|---|
|🧱 建立型|建立物件|建立邏輯複雜、重複|複雜建構、工廠管理|
|🧩 結構型|類別組合|耦合高、彈性差|系統架構封裝、資源代理|
|🎭 行為型|物件互動|責任不清、邏輯分散|通訊流程、行為擴充|