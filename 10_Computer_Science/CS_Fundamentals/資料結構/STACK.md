# 堆疊 (Stack)
堆疊是一種線性的資料結構，遵循**後進先出 (LIFO, Last-In, First-Out)** 的原則。它的運作方式就像一疊盤子，你只能從最上面新增或移除盤子。

## 特性
- **後進先出 (LIFO):** 最後被放入堆疊的元素，會是第一個被取出的元素。
- **有序性:** 元素在堆疊中是依照特定順序儲存的。

## 常見操作
- **Push (推入):** 將一個元素新增到堆疊的最頂端。
- **Pop (彈出):** 從堆疊的最頂端移除一個元素。
- **Peek (或 Top):** 回傳堆疊最頂端的元素，但不將其移除。
- **IsEmpty:** 檢查堆疊是否為空。
- **Size:** 回傳堆疊中元素的數量。

## 使用場景
- 函式呼叫管理 (呼叫堆疊)
- 軟體中的復原/重做功能
- 運算式求值 (例如：中序轉後序)
- 回溯演算法 (例如：迷宮求解)

## 實作方式
堆疊可以使用多種底層資料結構來實作，最常見的是：

### 1. 基於陣列的實作
- 使用固定大小或動態陣列來儲存元素。
- 一個 `top` 指標 (或索引) 用來追蹤頂端元素。
- **優點:** 存取速度快 (因記憶體連續)、實作簡單。
- **缺點:** 如果使用固定大小的陣列，當陣列滿了會導致堆疊溢位 (stack overflow)。動態調整陣列大小的成本可能很高。

### 2. 基於鏈結串列的實作
- 每個元素都是鏈結串列中的一個節點。
- 串列的 `head` 節點作為堆疊的 `top`。
- **Push** 操作會在 `head` 處新增一個節點。
- **Pop** 操作會移除 `head` 節點。
- **優點:** 大小可動態調整，沒有溢位的風險。
- **缺點:** 需要額外的記憶體來儲存指標，且因為記憶體不連續，速度可能比陣列稍慢。

## 複雜度分析
| 操作 | 陣列實作 | 鏈結串列實作 |
| :-------- | :------------------: | :------------------------: |
| **Push**  |         O(1)         |            O(1)            |
| **Pop**   |         O(1)         |            O(1)            |
| **Peek**  |         O(1)         |            O(1)            |
| **Search**|         O(n)         |            O(n)            |
| **Space** |         O(n)         |            O(n)            |

*注意：對於陣列實作，若需要重新調整陣列大小，Push 操作的最壞情況可能是 O(n)。*
