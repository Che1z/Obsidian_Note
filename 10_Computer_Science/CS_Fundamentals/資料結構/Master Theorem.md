# Master Theorem (大師定理)

Master Theorem 是一個用來快速求解「分治演算法 (Divide and Conquer)」時間複雜度的強大公式。當一個問題可以被遞迴地分解成數個規模更小的子問題時，我們就能用它來分析其效能。

### 核心：遞迴關係式

分治演算法的時間複雜度通常可以表示成以下的遞迴關係式：

**`T(n) = aT(n/b) + f(n)`**

這裡的每個符號都有其意義：

*   **`T(n)`**: 解決規模為 `n` 的問題所需的時間。
*   **`a`**: 遞迴分解成的「子問題數量」(`a >= 1`)。
*   **`n/b`**: 每個子問題的「規模」(`b > 1`)。
*   **`f(n)`**: 「分解(Divide)」問題與「合併(Combine)」子問題結果所需的成本。

#### 舉例: Merge Sort (合併排序)

Merge Sort 是 Master Theorem 的經典應用範例。

1.  **分解**: 將 `n` 個元素的陣列分成 `2` 個子陣列 (`a = 2`)。
2.  **子問題規模**: 每個子陣列的規模是 `n/2` (`b = 2`)。
3.  **合併**: 將兩個已排序的子陣列合併成一個完整的排序陣列，這個過程需要 `n` 次比較與移動，所以成本為 `f(n) = n`。

因此，Merge Sort 的遞迴關係式為：

**`T(n) = 2T(n/2) + n`**

--- 

### 如何從關係式推論出時間複雜度？

Master Theorem 的精髓在於比較「**遞迴子問題的總成本**」與「**分解/合併步驟的成本**」這兩者的**成長速度**，看誰是演算法效能的瓶頸。

1.  **遞迴子問題的成本**：由 `a` 和 `b` 決定，其成本的成長速度由函式 **`n^(log_b(a))`** 代表。 (想知道這個函式為什麼代表子問題的總成本？ [[Master Theorem n^C的直觀解釋]] )
2.  **分解/合併的成本**：由函式 **`f(n)`** 代表。

我們的目標就是比較 `f(n)` 和 `n^(log_b(a))` 這兩個函式，看誰增長得更快。

---

### Master Theorem 的三種情境

假設遞迴式為 `T(n) = aT(n/b) + f(n)`。為了方便比較，我們**不是**直接比較 `f(n)` 和一個數字，而是比較 **`f(n)` 函式**與 **`n^C` 函式** 的成長級別，其中 `C` 是一個由 `log_b(a)` 計算出來的常數，作為成長率的基準。

#### **Case 1: `f(n)` 的成長慢於 `n^C`**

如果分解/合併的成本 `f(n)`，比子問題求解的成本 `n^C` 要「輕」很多（學術上稱為 polynomially smaller），那麼整個演算法的複雜度就由「子問題求解」主導。

*   **條件**: `f(n) = O(n^(C - ε))`，其中 `ε > 0` (代表 `f(n)` 的次方嚴格小於 `C`)。
*   **結果**: `T(n) = Θ(n^C)`

*   **範例**: `T(n) = 8T(n/2) + n^2`
    *   `a=8, b=2, f(n)=n^2`
    *   `C = log_2(8) = 3`
    *   `f(n) = n^2` 的成長慢於 `n^3` (滿足 `n^2 = O(n^(3-1))`)。
    *   屬於 Case 1，因此 `T(n) = Θ(n^3)`。

#### **Case 2: `f(n)` 的成長與 `n^C` 相當**

如果分解/合併的成本 `f(n)`，和子問題求解的成本 `n^C` 勢均力敵，那麼總成本需要在原有的基礎上再乘以一個對數因子 `log n`。

*   **條件**: `f(n) = Θ(n^C)`。
*   **結果**: `T(n) = Θ(n^C * log n)`

*   **範例**: `T(n) = 2T(n/2) + n` (Merge Sort)
    *   `a=2, b=2, f(n)=n`
    *   `C = log_2(2) = 1`
    *   `f(n) = n` 的成長與 `n^1` 相當 (滿足 `n = Θ(n^1)`)。
    *   屬於 Case 2，因此 `T(n) = Θ(n * log n)`。

#### **Case 3: `f(n)` 的成長快於 `n^C`**

如果分解/合併的成本 `f(n)`，比子問題求解的成本 `n^C` 要「重」很多（polynomially larger），那麼整個演算法的複雜度就由「分解/合併」這一步主導。

*   **條件**: 
    1.  `f(n) = Ω(n^(C + ε))`，其中 `ε > 0` (代表 `f(n)` 的次方嚴格大於 `C`)。
    2.  並且滿足「正規性條件 (regularity condition)」: `a * f(n/b) <= k * f(n)`，其中 `k` 是一個小於 1 的常數。 (這個條件主要是為了排除一些行為不穩定的 `f(n)` 函數，但在常見的演算法中通常會滿足)。
*   **結果**: `T(n) = Θ(f(n))`

*   **範例**: `T(n) = 3T(n/4) + n log n`
    *   `a=3, b=4, f(n)=n log n`
    *   `C = log_4(3) ≈ 0.79`
    *   `f(n) = n log n` 的成長快於 `n^0.79` (滿足 `n log n = Ω(n^(0.79+0.2))`)。
    *   正規性條件也滿足。
    *   屬於 Case 3，因此 `T(n) = Θ(n log n)`。

--- 

### Master Theorem 不是無敵的

大師定理雖然強大，但也有其限制。在以下情況，Master Theorem 會「失效」：

1.  **`f(n)` 與 `n^C` 的差距太小**: 例如 `f(n) = n^C / log n`，這種差距不是多項式級別的，不符合任何一種 Case。
2.  **`a` 不是常數**: 例如 `a = 2n`。
3.  **`b` 不是常數**或 `b <= 1`。
4.  **`f(n)` 不是正數**或包含非多項式函數 (例如 `sin(n)`)。

在這些情況下，我們需要使用其他方法，如遞迴樹法 (Recursion Tree) 或代入法 (Substitution Method) 來求解。