# Binary Search (二分搜尋法)

Binary Search 是一種在「**已排序**」陣列中尋找目標值的高效演算法。它的核心思想是「分治法」，透過不斷地將搜尋範圍縮小一半來快速定位目標。

### 核心概念

Binary Search 利用了資料「已排序」的特性。它不從頭開始找，而是直接檢查中間的元素。

*   如果中間元素就是目標，搜尋結束。
*   如果中間元素比目標小，那麼目標必定在右半邊，因此拋棄左半邊。
*   如果中間元素比目標大，那麼目標必定在左半邊，因此拋棄右半邊。

這個過程不斷重複，每次都讓搜尋範圍減半，直到找到目標或範圍縮小為零。

*   **比喻**：就像在字典裡查單字。你不會從第一頁開始翻，而是直接翻到中間，看中間的字母是比你要找的字首字母前面還是後面，然後決定要往前翻還是往後翻，每次都排除掉一半的頁數。

### 演算法步驟 (以疊代法為例)

1.  設定兩個指標，`left` 指向陣列開頭，`right` 指向陣列結尾。
2.  當 `left <= right` 時，重複以下步驟：
    a. 計算中間索引 `mid = floor((left + right) / 2)`。
    b. 比較 `array[mid]` 與目標值。
    c. 如果 `array[mid]` 等於目標值，搜尋成功，返回 `mid`。
    d. 如果 `array[mid]` 小於目標值，表示目標在右側，更新 `left = mid + 1`。
    e. 如果 `array[mid]` 大於目標值，表示目標在左側，更新 `right = mid - 1`。
3.  如果迴圈結束後仍未找到，表示目標不存在。

### 複雜度

*   **時間複雜度**: `O(log n)`。每次操作都將搜尋範圍縮小一半，因此複雜度是對數級別的，這也符合 [[Lower bound of searching and sorting|搜尋問題的理論下限]]。
*   **空間複雜度**: `O(1)` (疊代法) 或 `O(log n)` (遞迴法，因為需要函式呼叫堆疊)。

### 優缺點

*   **優點**：
    *   搜尋效率極高，特別適用於大型資料集。
*   **缺點**：
    *   **硬性要求**：必須應用於**已排序**的資料集。如果資料未排序，則必須先花費時間進行排序（例如 `O(n log n)`），總成本可能會更高。
