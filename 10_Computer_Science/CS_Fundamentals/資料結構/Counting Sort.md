# Counting Sort (計數排序)

Counting Sort 是一種高效的整數排序演算法，其核心思想是「以空間換取時間」。它適用於**已知整數範圍**（例如 0 到 k 之間）的資料集。

### 核心概念

它不是透過比較元素來排序，而是透過計算每個整數在資料集中出現的「次數」來確定每個元素的最終位置。

### 演算法步驟

假設要排序的資料範圍在 0 到 `k` 之間：

1.  **建立計數陣列**：建立一個大小為 `k+1` 的計數陣列 `count`，並將所有值初始化為 0。
2.  **計數**：遍歷原始輸入陣列，對於每個元素 `x`，將 `count[x]` 的值加 1。完成後，`count[x]` 就儲存了等於 `x` 的元素的個數。
3.  **計算累積次數**：修改 `count` 陣列，使其每個索引 `i` 的值，變成「小於或等於 `i` 的元素的總數」。這可以透過遍歷 `count` 陣列，讓 `count[i] = count[i] + count[i-1]` 來完成。
4.  **放置到結果陣列**：建立一個與輸入陣列相同大小的輸出陣列 `output`。反向遍歷原始輸入陣列，對於每個元素 `x`：
    a. 查表 `count[x]` 得知 `x` 應該放在輸出陣列的哪個位置。
    b. 將 `x` 放入 `output[count[x] - 1]`。
    c. 將 `count[x]` 的值減 1，為下一個相同的元素做準備。

### 複雜度

*   **時間複雜度**: `O(n + k)`，其中 `n` 是元素數量，`k` 是整數範圍的最大值。當 `k` 與 `n` 在同一個數量級時，可以視為 `O(n)`。
*   **空間複雜度**: `O(k)`，需要一個額外的計數陣列。

### 特性

*   **穩定 (Stable)**：排序後，相同元素的相對順序不會改變。這個特性對於 [[Radix Sort]] 至關重要。
*   **非比較排序**：完全不涉及元素間的比較，因此能突破 `Ω(n log n)` 的下限。
