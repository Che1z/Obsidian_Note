# 佇列 (Queue)
佇列是一種線性的資料結構，遵循**先進先出 (FIFO, First-In, First-Out)** 的原則。它的運作方式就像排隊，第一個進入隊伍的人，會是第一個離開的。

## 特性
- **先進先出 (FIFO):** 最先被放入佇列的元素，會是第一個被取出的元素。
- **有序性:** 元素在佇列中是依照特定順序儲存的。

## 常見操作
- **Enqueue (入隊):** 將一個元素新增到佇列的尾端 (rear)。
- **Dequeue (出隊):** 從佇列的前端 (front) 移除一個元素。
- **Peek (或 Front):** 回傳佇列最前端的元素，但不將其移除。
- **IsEmpty:** 檢查佇列是否為空。
- **Size:** 回傳佇列中元素的數量。

## 使用場景
- 任務排程 (例如：CPU 排程、印表機佇列)
- 圖論中的廣度優先搜尋 (BFS)
- 緩衝資料流 (例如：網路)
- 處理共享資源的請求

## 實作方式
佇列可以使用多種底層資料結構來實作：

### 1. 基於陣列的實作 (環形佇列)
- 使用固定大小或動態陣列。為避免從前端移除元素時產生 O(n) 的複雜度，通常會實作為**環形佇列 (Circular Queue)**。
- 使用 `front` 和 `rear` 兩個指標來追蹤佇列的頭跟尾。
- 當元素出隊時，`front` 指標前進；當元素入隊時，`rear` 指標前進。指標會視情況環繞回陣列的開頭。
- **優點:** 能有效利用一塊固定的記憶體空間。
- **缺點:** 實作上可能較為複雜。若使用固定大小陣列，佇列可能會滿。

### 2. 基於鏈結串列的實作
- 每個元素都是單向鏈結串列中的一個節點。
- 維護 `front` (或 `head`) 和 `rear` (或 `tail`) 兩個指標。
- **Enqueue** 操作會在 `rear` 處新增一個節點。
- **Dequeue** 操作會移除 `front` 處的節點。
- **優點:** 大小可動態調整，實作 enqueue/dequeue 邏輯簡單。
- **缺點:** 相較於陣列，需要額外的記憶體來儲存指標。

### 3. 使用兩個堆疊實作
- 這是常見的面試問題，可以使用兩個堆疊來模擬一個佇列。
- **Enqueue:** 將元素推入 `stack1`。
- **Dequeue:** 如果 `stack2` 是空的，就將 `stack1` 的所有元素彈出並推入 `stack2`。然後從 `stack2` 彈出元素。這個過程顛倒了元素的順序，從而模擬了 FIFO 的行為。
- **優點:** 一個有趣的理論練習。
- **缺點:** 當 `stack2` 為空需要重新填充時，Dequeue 操作的成本可能很高 (O(n))。

## 複雜度分析
| 操作 | 陣列 (環形) | 鏈結串列 | 兩個堆疊 (攤銷) |
| :-------- | :--------------: | :---------: | :--------------------: |
| **Enqueue**|       O(1)       |    O(1)     |          O(1)          |
| **Dequeue**|       O(1)       |    O(1)     |      O(1) (攤銷)      |
| **Peek**   |       O(1)       |    O(1)     |      O(1) (攤銷)      |
| **Space**  |       O(n)       |    O(n)     |          O(n)          |

*注意：對於雙堆疊實作，單次 Dequeue 操作的最壞情況可能是 O(n)，但一系列操作的平均時間是 O(1)，稱為攤銷常數時間 (Amortized Constant Time)。*
