1.物件導向程式設計的三大基本特性是什麼？ 
```c#
Encapsulation (封裝)、Inheritance(繼承)、Polymorphism(多型)
```
2.定義函數重載（Function Overload）並給出一個使用不同參數的方法重載例子。 
```c#
public static int Add(int x, int y)
{
	return x + y;
}

public static int Add(int x, int y, int z)
{
	return x + y + z;
}
```
3.建構函式在 C# 中的用途是什麼？提供一個帶有參數的建構函式的例子。
```c#
目的在於初始化Class

public class MyCar
{
	private int _Speed;
	private int _FactoryYear;
	public MyCar(int value){
		this._Speed = value;
		this._FactoryYear = 1996;
	}
	public int getSpeed(){
		return this._Speed;
	}
}

```
4.提供一個例子，展示如何在 C# 中覆寫父類別。 
```C#
public class Animal
{
	public virtual void MakeSound(){
		Console.WriteLine("Animal make sounds");
	}
}

public class Dog : Animal
{
	public override void MakeSound(){
		Console.WriteLine("Dog make sounds");
	}
}

```
5.舉例說明如何使用 this 和 base 關鍵字。
```c#
public class Animal
{
	public virtual void MakeSound(){
		Console.WriteLine("Animal make sounds");
	}
}

public class Dog : Animal
{
	private int _age;
	// Constructor ( 兩種寫法：static Dog(){}或public Dog(){} )
	public Dog(){
		this._age = 10;
	}

	public override void MakeSound(){
		Console.WriteLine("Dog make sounds");
		base.MakeSound();
	}

}
```
6.給一個介面例子，其中一個類別實作該介面。 
```C#
interface IMakeSound
{
	void makeSound();
}

class Animal: IMakeSound
{
	public void makeSound(){
		Console.WriteLine("Animal make sound");
	}
}

class Program
{
	static void Main(string[] args)
        {

            Animal animal = new Animal();
            IMakeSound makeSound = animal;
            makeSound.makeSound();

			Animal animal2 = new Animal();
			animal2.makeSound();
            Console.ReadKey();
        }

}
```

7.如何在 C# 中使用介面來實現多形？提供一個具體的例子。
``` c#
public interface IMakeSound
    {
        void MakeSound();
    }

public class Animal : IMakeSound
{
	public void MakeSound()
	{
		Console.WriteLine("Animal make sound");
	}
}
public class Dog : IMakeSound
{
	public void MakeSound()
	{
		Console.WriteLine("Dog make sound");
    }
}

public class AnimalMakeSoundManager
{
	public static void MakeSoundFromAnimal(IMakeSound animal)
	{
		animal.MakeSound();
	}
}

class Program
{
	static void Main(string[] args)
	{
		AnimalMakeSoundManager.MakeSoundFromAnimal(new Animal());
		AnimalMakeSoundManager.MakeSoundFromAnimal(new Dog());
		Console.ReadKey();
	}
}

```

8.在 C# 中，當一個類別被聲明為 sealed 時，其成員（方法、屬性等）還可以被覆寫嗎？解釋原因。 
```c#
不可能，因為sealed就是最後一個class，不會有子類別能夠覆寫其成員的可能存在
```

9.解釋靜態修飾詞 static 在 C# 中的何時使用，並給出靜態方法的一個例子。 
```C#
靜態方法，意指無需實例化，即可使用的class方法。
不會因為實例化而有差異的方法內容即可使用靜態修飾詞

class Animal{
	public static void makeSound(){
		Console.WriteLine("Animal make sounds");
	}
}
```

10.給出一個範例，展示如何通過自動實作屬性來簡化代碼。 
```C#
//自動實作屬性：{get; set;}
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Email { get; set; }
}

//若無使用
public class Person
{
    private string name;
    private int age;
    private string email;

    public string Name
    {
        get { return name; }
        set { name = value; }
    }

    public int Age
    {
        get { return age; }
        set { age = value; }
    }

    public string Email
    {
        get { return email; }
        set { email = value; }
    }
}

```
11.解釋何時應使用 readonly 屬性，並給出一個例子。 
``` C#
readonly 關鍵字是用於readonly 適用於運行時常量（run-time constants），這些值在實例化過程中可以被設置，之後就不能改變。
它適用於以下情況：

1. 當欄位的值在對象創建後就不應該改變時。
2. 防止欄位被意外修改，提高代碼的安全性和可靠性。
3. 用於表示常量或只初始化一次的配置值。

class Car
{
	private readonly int _speed;
	public Car(int value){
		this._speed = value;
	}
	public void GetSpeed(){
		Console.WriteLine($"Car speed : {this._Speed}");
	}
}

```
12.示範如何在 C# 中重載一個類別的建構函式並解釋其目的。 
```C#
目的是在於提供靈活性，當實例化物件時，可針對需求填入不同參數，完成不同的物件
class Car
{
	private int _speed;
	public Car()
	{
		this._speed = 10;
	}
	
	public Car(int value)
	{
		this._speed = value;
	}
	public void GetSpeed(){
		Console.WriteLine($"Speed : {this._speed}");
	}
}
```

13.請提供一個介面包含屬性的例子。 
```C#
 interface IMakeSound
    {
        void GetNoise();
        //可讀可寫
        string noise { get; set; }
        //可讀
        string name { get; }
    }

    class Animal : IMakeSound
    {
        public string noise { get; set; }
        public string name { get; }
        public void GetNoise() {
            Console.WriteLine($"Animal {this.name} make {this.noise} noise");
        }

        public Animal() {
            this.noise = "Woff";
            this.name = "Apple";
        }
    }
```

14.什麼是 sealed 類別，並解釋其如何用來限制繼承。
```c#
Sealed意為著是最後一個class，無法被任何類別繼承，若有任何class嘗試繼承sealed class都會導致編譯錯誤

sealed class SealedClass {
        public virtual void Message() {
            Console.WriteLine("Make message");
        }
    }

// :SealedClass 這邊會報錯
class Car : SealedClass {
        public void Ignite() {
            Console.WriteLine("Finish ignite");
        }
        public override void Message()
        {
            Console.WriteLine("Change Message");
            base.Message();
        }
    }

```
```
14.在 C# 中，當一個類別被聲明為 sealed 時，其成員（方法、屬性等）還可以被覆寫嗎？解釋原因。
```
15.定義函數重載（Function Overload）並給出一個使用不同參數的方法重載例子。

``` c#
//寫在program class裡頭，可直接藉由functin name完成invoke
public static int Add (int x, int y){
	return x + y;
}

public static int Add(int x, int y, int z){
	return x + y + z;
}
```

16.在C#中，類別與物件之間的關係是什麼？
```c#
物件是按照類型規範所製作出來的實體，類別就像是物件的設計藍圖。
```

17.請解釋 C# 中的存取修飾詞 有哪些，並解釋它們 的作用與差異。
```c#
public ： class內、衍生class(相同，不同專案)、非衍生class(相同、不同專案)皆可讀取。
protected ：class內、衍生class(相同、不同專案)皆可讀取
internal ： class內、衍生class(相同專案)、非衍生class(同專案)皆可讀取
protected internal：class內、衍生(相同、不同專案)、非衍生class(同專案)皆可讀取
private：class內，皆可讀取
private protected：class內、衍生類型(相同專案)皆可讀取
```
18.什麼是欄位，以及它與屬性有何不同？
```c#
欄位是類別裡頭的變數，屬性則是提供對於欄位的封裝訪問方式
```
19.請示範如何在 C# 中創建一個具有私有欄位和公共屬性的類別。
```c#
class myCar
    {
        private int _year;
        public int getYear
        {
            get { return this._year; }
            set
            {
               this._year = value;
            }
        }
        public myCar(int year = 20){
	        this._year = year;
        }
        public void getDetail() {
            Console.WriteLine($"Car manufacter year : {this._year}");
        }
    }

class Program{
	static void Main(string[] args)
        {
            myCar myCar = new myCar();
            myCar.getYear = 47;
            myCar.getDetail(); //Car manufacter year : 47
            Console.ReadKey();
        }
}
```

20.解釋 C# 中繼承的概念並給出一個簡單範例
```C#
繼承允許我們能減少撰寫重複代碼，衍生類別可以透過繼承，直接獲得基本類別裡頭的屬性、方法資料。
 class MyCar
    {
        public string year { set; get; }
       
        public void getInfo()
        {
            Console.WriteLine($"The Car is a prototype car");
        }
        public virtual void getYear() {
            Console.WriteLine($"The Car is built at {year}");
        }
    }

    class Lexus : MyCar
    {
        public override void getYear()
        {
            Console.WriteLine($"The Car is still building.... Probably {year}");
        }
    }
 
 class Program 
    {
        static void Main(string[] args)
        {
            Lexus lexus = new Lexus {
                year = "2024"
            };
            lexus.getYear();
            lexus.getInfo();
            Console.ReadKey();
        }
    }
```

21.解釋抽象類別，並給出一個的抽象類別的例子。
```c#
抽象類別意指無法被實例化的類別，需透過繼承才能將其定義的內容實體化
abstract class PrototypeCar
    {
        public string name { get; set; }
        public int year { get; set; }
        
        public abstract void showInfo();
    }

    class Car : PrototypeCar 
    {
        public Car() {
            this.name = "Tesla";
            this.year = 2024;
        }
        public override void showInfo() { 
	        Console.WriteLine($"{Name} at {Year}"); 
	    }
    }
    
class Program
    {
        static void Main(string[] args)
        {
            Car car = new Car();
            car.showInfo(); // Tesla at 2024
            Console.ReadKey();
        }
    }
```

22.描述如何使用抽象方法強制子類別提供特定功能的實現。
```c#
抽象方法是一種沒有實作的方法，其定義在抽象類別中。
所有繼承該抽象類別的子類別都需要提供抽象方法的實際具體實踐方法。
```

!!23.給出一個範例，展示如何在子類別中使用 base 來調用基類的構造函數。

```C#
class PrototypeCar
    {
        public string _name { get; set; }
        public int _year { get; set; }

        public PrototypeCar(string name, int year)
        {
            this._name = name;
            this._year = year;

        }
        public void showInfo()
        {
            Console.WriteLine($"{_name} at {_year}");
        }
    }

    class Car : PrototypeCar
    {
        public Car(string name, int year) : base(name, year)
        {
            this._name = name;
            this._year = year;
        }
    }
 class Program
    {
        static void Main(string[] args)
        {
            Car car = new Car("Tesla", 2024);
            car.showInfo();
            Console.ReadKey();
        }
    }
```

24.在多層繼承結構中，如何確保父類別的某些方法不能被某個特定層級的子類或所有子類覆寫。
```C#
要確保父類別的某些方法不能被某個特定層級的子類或所有子類覆寫，可以使用 `sealed` 修飾詞來防止方法的進一步覆寫。

// 基類
class Animal
{
    // 可以被子類別覆寫的虛擬方法
    public virtual void MakeSound()
    {
        Console.WriteLine("Animal sound");
    }
}

// 直接繼承自 Animal 類的中間類別
class Dog : Animal
{
    // 覆寫基類的方法，並防止進一步覆寫
    public sealed override void MakeSound()
    {
        Console.WriteLine("Dog barks");
    }
}

// 直接繼承自 Dog 類的最底層子類別
class Bulldog : Dog
{
    // 試圖覆寫 Dog 類中的方法會導致編譯錯誤
    // public override void MakeSound() 
    // {
    //     Console.WriteLine("Bulldog growls");
    // }
}


```

!!25.什麼是介面（Interface）?
```c#
介面（Interface）是一種定義類別應實作哪些方法和屬性的結構，無需實作這些方法和屬性的具體行為。
介面只定義了方法的簽名和屬性，但不提供實作細節。
```
26.解釋多形（Polymorphism）
```C#
多形（Polymorphism）是物件導向程式設計中的一個核心概念，指的是同一方法或屬性名稱在不同的類別中可以有不同的實作。
多形允許不同的對象以相同的接口進行操作，但每個對象可以實現不同的行為。
```
27.請說明介面可以透過繼承而加以擴展
```C#
介面可以通過繼承來擴展。當一個介面繼承自另一個介面時，子介面將繼承父介面的所有成員，並且可以添加新的成員或修改已有的成員。
這樣，實作子介面的類別必須實作所有從父介面繼承來的成員。

interface IShape
{
    void Draw();
}

interface IColorable : IShape
{
    void SetColor(string color);
}

class Circle : IColorable
{
    public void Draw()
    {
        Console.WriteLine("Drawing a circle");
    }

    public void SetColor(string color)
    {
        Console.WriteLine($"Setting circle color to {color}");
    }
}


```
28.舉例說明如何通過一個類來實作多個介面
```C#
在 C# 中，一個類可以實作多個介面。這允許該類具備多個介面的功能。
interface IReadable
{
    void Read();
}

interface IWritable
{
    void Write();
}

class Document : IReadable, IWritable
{
    public void Read()
    {
        Console.WriteLine("Reading document");
    }

    public void Write()
    {
        Console.WriteLine("Writing document");
    }
}

```
29.介面與抽象類別有什麼不同
```C#
- 介面：   
    - 只定義方法簽名和屬性，無法包含具體的實作。
    - 支持多重繼承，一個類可以實作多個介面。
    - 介面不能有構造函數、字段或靜態成員。
      
- 抽象類別：   
    - 可以包含方法的具體實作、字段、屬性、構造函數等。
    - 不支持多重繼承，一個類只能繼承自一個抽象類別。
    - 可以包含靜態成員和字段。
```
30.介面可以定義構造函數嗎?
```C#
介面不能定義構造函數。構造函數用於初始化類別的實例，而介面只定義合約，沒有實例化的能力，因此不能有構造函數。
```
31.介面的成員默認的存取修飾詞是什麼?
```c#
介面的成員默認為 `public`。無論你是否明確指定存取修飾詞，介面中的方法和屬性都被視為 `public`，因為介面成員的目的是被實作類別所訪問和實現。
```
32.在 C# 中，一個類實作介面時，必須實作介面的所有成員嗎?
```c#
是的，當一個類實作介面時，必須實作介面中定義的所有成員，否則該類將無法編譯通過。這是因為介面定義了一組合約，實作該介面的類別必須提供這些合約的具體實作。
```
